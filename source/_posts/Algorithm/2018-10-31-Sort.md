---
title: 排序算法笔记
date: 2018-10-31 14:20:52
categories:
- Algorithm
tags:
- Algorithm
- Sort
- Note
---
# 排序是什么

将无序的集合通过一定的算法处理，得到一个有序集合。

# 常见的排序算法

按难度（个人）分：

- 基础
    - [冒泡排序](#冒泡排序)
    - [选择排序](#选择排序)
- 一定难度
    - [归并排序](#归并排序)
    - [原地归并排序](#原地归并排序)
    - [桶排序](#桶排序)
    - [二叉排序树](#二叉排序树)
    - [快速排序](#快速排序)
    - [堆排序](#堆排序)
    - [希尔排序](#希尔排序)

## 冒泡排序

### 描述

Bubble Sort 冒泡排序
它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

### 原理/过程

1. 比较相邻的两个元素（一对），如果顺序不符合要求（升序或降序），则调换顺序。
2. 对每一对元素重复1的操作，即从第一对到最后一对，最后一个元素将会是最大的元素。
3. 持续对上一步操作后少一个元素的集合重复1,2的操作(即每次循环排除最后一个元素的集合),直到没有元素

### 时间复杂度

算法可以实现原地排序，但是需要嵌套循环集合，效率较低

在上步的2中有一个关于n的循环,3中也有一个

可知时间复杂度 $ O(n^2) $

### 代码实现

``` csharp BubbleSort
public class BubbleSort{
    public static void Sort(int[] arr){
        //获得数组长度
        int n = arr.getLength(0);
        //进行n次,每一次的处理长度都减1
        for(int i = 0;i < n;i++){
            //处理每次相邻比较
            for(int j = 0;j < n - i - 1;j++){
                //如果前一个元素大于后一个元素，不符合升序
                //交换前后元素
                if(arr[j] > arr[j + 1]){
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;
                }
            }
        }
    }
}
```

## 选择排序

与冒泡相似，都是每次循环中，从$1\rightarrow n$中选出最大（或最小的）放在 $n$ 上，$n$递减并重复之前的操作。

### 原理/过程

1. 从未排序的集合中，找到最小（大）的元素，放在序列的最起始（末尾）位置
2. 最起始（末尾）的以前（以后）的元素有序，重复操作未排序的集合，直到所有元素排序完毕。

### 时间复杂度

与冒泡相似，都是选择极值放置到相应的序列位置上。
相比冒泡的相邻比较，可能每次比较都会发生交换。
复杂度依旧集中在一个两层循环中，简单可得复杂度：$$O(n^2)$$

### 代码实现

``` csharp SelectSort
public class SelectSort{
    public static void Sort(int[] arr){
        //获得数组长度
        int n = arr.getLength(0);
        //第n次选择，或已有n个元素排序完成
        for(int i = 0;i < n;i++){
            int k = i;
            for(int j = 0;j < n - 1 - i;j++){
                if(arr[j] < arr[k])
                    k = j;
            }
            //swap
            int tmp = arr[k];
            arr[k] = arr[i];
            arr[i] = tmp;
        }
    }
}
```

## 快速排序

### 原理/过程

### 时间复杂度

### 代码实现

<!-- ## 归并排序

### 原理/过程

### 时间复杂度

### 代码实现

## 原地归并排序

### 原理/过程

### 时间复杂度

### 代码实现

## 桶排序

### 原理/过程

### 时间复杂度

### 代码实现

## 二叉排序树

### 原理/过程

### 时间复杂度

### 代码实现

## 堆排序

### 原理/过程

### 时间复杂度

### 代码实现

## 希尔排序

### 原理/过程

### 时间复杂度

### 代码实现 -->
